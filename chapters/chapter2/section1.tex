\section{روش‌های Anti Anti Disassembly}
\label{sec:ch2-aada_intro}
\subsection{مقدمه ای بر ضد ضد دی‌اسمبل (Anti-Anti-Disassembly)}
در دنیای مدرن نرم‌افزار، کد منبع (Source Code) هسته اصلی مالکیت فکری و ارزش تجاری هر محصولی است. با افزایش پیچیدگی سیستم‌ها و گسترش تهدیدات امنیتی، نیاز به جلوگیری از مهندسی معکوس (Reverse Engineering)، سرقت فکری، و تحلیل بدافزارها اهمیت حیاتی یافته است. این نیاز، توسعه‌دهندگان نرم‌افزار را به سمت استفاده از تکنیک‌هایی تحت عنوان اُبفوسکیشن (Obfuscation) و ضد دی‌اسمبل (Anti-Disassembly - AD) سوق داده است.
\subsection{تعریف Anti-Disassembly (AD):}
Anti-Disassembly مجموعه‌ای از ترفندها و الگوهای برنامه‌نویسی است که عمداً برای گمراه کردن ابزارهای تحلیل استاتیک (مانند دی‌اسمبلرها و دکامپایلرها) طراحی شده‌اند. این تکنیک‌ها با هدف شکستن نمودار جریان کنترل (Control Flow Graph - CFG) و جلوگیری از تفسیر صحیح دستورات ماشین توسط ابزارهای خودکار به کار می‌روند. روش‌هایی مانند قرار دادن بایت‌های فیک، پرش‌های نامعتبر، یا پرش‌های داینامیک محاسبه‌شده، تحلیل کد را برای انسان بسیار دشوار و زمان‌بر می‌سازند.

\subsection{ورود به Anti-Anti-Disassembly (AADA)}
ضد ضد دی‌اسمبل (Anti-Anti-Disassembly - AADA)، در پاسخ به تکنیک‌های AD، به وجود آمده است. AADA نه تنها یک ابزار، بلکه یک فلسفه مقابله‌ای در مهندسی معکوس است. این حوزه به مجموعه‌ای از روش‌های پیشرفته و هوشمندانه اشاره دارد که توسط متخصصان امنیت و تحلیلگران بدافزار برای شناسایی، تجزیه و خنثی کردن عمدی لایه‌های محافظتی و مبهم‌سازی کد ایجاد شده‌اند.

هدف غایی AADA این است که به‌طور موفقیت‌آمیز شفافیت (Clarity) و دقت (Accuracy) تحلیل را به کد بازگرداند. این فرآیند اغلب شامل تحلیل دینامیک (اجرای کنترل‌شده کد)، اجرای نمادین (Symbolic Execution) و اصلاح خودکار فایل‌های باینری (Patching) است تا موانع AD برداشته شده و تحلیلگر بتواند به منطق اصلی برنامه دست یابد.
\subsection{اهمیت در تکامل نرم‌افزار}
در چارچوب درس تکامل نرم‌افزار (Software Evolution)، AADA نقش حیاتی در فرآیندهای نگهداری پیشگیرانه (Preventive Maintenance) و ممیزی امنیتی (Security Auditing) ایفا می‌کند. دانش AADA به تیم‌های توسعه و امنیت این امکان را می‌دهد که:
\begin{itemize}
    \item بدافزارها را تحلیل کنند:برای درک نحوه عملکرد کدهای مخرب که از AD برای پنهان شدن استفاده می‌کنند.
    \item اثربخشی محافظت را ارزیابی کنند: برای تست و ارزیابی مقاومت تکنیک‌های حفاظت از کد خود در برابر پیشرفته‌ترین روش‌های شکستن آن.
\end{itemize}
\subsection{تکنیک‌های کلیدی ضد ضد دی‌اسمبل (AADA)}
تکنیک‌های AADA به طور مستقیم هدف‌گذاری شده‌اند تا موانعی را که روش‌های Anti-Disassembly (AD) برای گمراه کردن تحلیل استاتیک ایجاد کرده‌اند، از بین ببرند. موفقیت AADA به توانایی تحلیلگر در ترکیب ابزارهای استاتیک و دینامیک بستگی دارد.
\begin{enumerate}
\item{تحلیل دینامیک و رصد (Dynamic Analysis and Tracing)}
\label{subsec:dynamic_analysis}

بسیاری از تکنیک‌های AD به متغیرهای وابسته به زمان اجرا (Runtime) تکیه دارند (مانند پرش‌های محاسبه‌شده). تحلیل دینامیک مؤثرترین روش برای غلبه بر این موانع است.

\begin{itemize}

\item{استفاده از اشکال‌زداها (Debuggers)}
اجرای کد در یک محیط کنترل‌شده (Sandbox) یا یک اشکال‌زدای سطح پایین مانند \lr{x64dbg} یا \lr{GDB} به تحلیلگر اجازه می‌دهد تا مقادیر رجیسترها و حافظه را در لحظهٔ اجرای دستورات حیاتی مشاهده کند.

\item{ردیابی دستورات (Instruction Tracing)}
در این روش توالی دقیق دستوراتی که در طول اجرای بخش مبهم‌سازی‌شده اجرا می‌شوند ثبت می‌گردد. این ردیابی می‌تواند آدرس‌های پرش‌های داینامیک را آشکار سازد و مسیر واقعی جریان کنترل را نشان دهد.

\item{استخراج آدرس‌های مقصد (Destination Address Extraction)}
در مورد پرش‌های محاسباتی مانند JMP [Register] یا CALL [Register]، تحلیل دینامیک مقدار نهایی رجیستر را در لحظهٔ پرش کشف می‌کند و آدرس مقصد واقعی را به‌صورت صریح به دست می‌دهد.
\end{itemize}


\item{وصله زدن و اصلاح کد (Patching and Code Modification)}
هنگامی که مقصد واقعی جریان کنترل کشف می‌شود، تحلیلگر اغلب بایت‌های اصلی فایل باینری را برای تسهیل تحلیل‌های بعدی اصلاح می‌کند.
\begin{itemize}
\item{NOPing دستورات فیک}
دستوراتی که توسط AD برای خراب کردن دی‌اسمبلر استفاده شده‌اند، با دستور NOP (No Operation) جایگزین می‌شوند. این کار دستورات را غیرفعال می‌کند اما اندازه کد را ثابت نگه می‌دارد و دی‌اسمبلر می‌تواند به درستی از دستورات فیک عبور کند.
\item{تبدیل پرش داینامیک به پرش استاتیک}
پس از کشف آدرس مقصد پرش داینامیک، تحلیلگر می‌تواند دستورات پیچیده را با یک دستور پرش استاتیک و مستقیم (JMP یا CALL) به آدرس کشف شده جایگزین کند. این کار به ابزارهای تحلیل استاتیک اجازه می‌دهد تا نمودار جریان کنترل (CFG) را به درستی بازسازی کنند.
\item{خنثی‌سازی تکنیک‌های ضد دی‌باگ}
حذف دستوراتی که عمداً برای شناسایی اشکال‌زدا و توقف برنامه (Anti-Debugging) طراحی شده‌اند.
\end{itemize}
\item{اجرای نمادین (Symbolic Execution)}
اجرای نمادین یک تکنیک پیشرفته است که به جای مقادیر واقعی ورودی، از نمادها استفاده می‌کند. این روش برای شکستن اُبفوسکیشن‌های سنگین که شامل عملیات ریاضی پیچیده هستند، بسیار قدرتمند است.
\begin{itemize}
\item{تحلیل نمادین پرش‌ها}
در سناریوهایی که آدرس پرش با عملیات ریاضی پیچیده‌ای بر روی متغیرهای داخلی محاسبه می‌شود، اجرای نمادین می‌تواند فرمول ریاضی محاسبه آدرس را به دست آورد و تمام مقادیر ممکن را تعیین کند.
\item{ابزارهای پیشرفته}
ابزارهایی مانند Angr و Triton از اجرای نمادین برای کاوش خودکار در مسیرهای اجرایی کد مبهم‌سازی شده و کشف مقاصد پنهان استفاده می‌کنند.
\end{itemize}
\item{اسکریپت‌نویسی خودکار (Automated Scripting)}
برای مقابله با حجم بالای اُبفوسکیشن و تکنیک‌های تکراری AD، تحلیلگران از قابلیت اسکریپت‌نویسی دی‌اسمبلرها استفاده می‌کنند.
\begin{itemize}
\item{اسکریپت‌های تخصصی}
نوشتن اسکریپت‌هایی (مانند IDAPython) که یک الگوی خاص AD را در کد شناسایی می‌کنند و به طور خودکار آن را خنثی می‌کنند (به عنوان مثال، اسکریپتی که به دنبال توالی بایت‌های خاص برای یک دستور نامعتبر می‌گردد و بلافاصله آن را NOP می‌کند).
\item{بازسازی CFG}
این اسکریپت‌ها اطلاعاتی را که از تحلیل دینامیک به دست آمده‌اند، در تحلیل استاتیک دی‌اسمبلر وارد می‌کنند تا نمودار جریان کنترل مجدداً با دقت بالا ترسیم شود.
\end{itemize}
\end{enumerate}