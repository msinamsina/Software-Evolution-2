\section{مقاومت در برابر تحلیل‌های ضد ضد دیس اسمبلی}
\label{sec:anti-anti-disassembly}

با پیشرفت گسترده ابزارهای تحلیل معکوس، تکنیک‌های کلاسیک ضد دیس‌اسمبلی دیگر به‌تنهایی نمی‌توانند امنیت کافی فراهم کنند. ابزارهای مدرنی همچون \lr{IDA Pro}، \lr{Ghidra}، \lr{Binary Ninja}، \lr{Radare2} و چارچوب‌های تحلیل پویا مانند \lr{DynamoRIO} و \lr{Intel PIN} قادرند بسیاری از تکنیک‌های قدیمی را شناسایی، نرمال‌سازی یا خنثی کنند \cite{eagle2020ida}. علاوه بر این، موتورهای تحلیل نمادین (\lr{Symbolic Execution}) مانند \lr{angr} و \lr{KLEE} نیز توانایی عبور از برخی موانع جریان کنترل را فراهم آورده‌اند.

در چنین شرایطی، نیاز به روش‌هایی برای ایجاد «لایه‌های مقاومت علیه ابزارهای \lr{Anti-Anti-Disassembly}» به‌وجود آمده است. این لایه‌ها نه‌تنها تحلیل استاتیک را دشوار می‌سازند، بلکه تحلیل پویا، اجرای نمادین و روش‌های خودکار مدرن را نیز با شکست مواجه می‌کنند. این بخش به بررسی جامع تکنیک‌هایی می‌پردازد که با هدف ایجاد مقاومت پایدار در برابر تحلیلگر انسانی و ابزارهای پیشرفته \lr{AADA} طراحی شده‌اند.

\subsection{لایه‌بندی چندمرحله‌ای ابهام‌سازی}
\label{sec:multi-layer-obfuscation}

در روش‌های سنتی، ابهام‌سازی معمولاً در یک سطح و با تکنیک‌هایی قابل پیش‌بینی اجرا می‌شد؛ اما ابزارهای ضد مبهم‌سازی قادرند بسیاری از آن‌ها را بازسازی کنند. روش چندمرحله‌ای جدید بر پایه وابستگی میان لایه‌ها طراحی می‌شود؛ به‌گونه‌ای که حذف یک لایه باعث فعال شدن لایه‌های دیگر یا ایجاد اجرای اشتباه می‌شود \cite{dang2014practical}.

این وابستگی‌ها معمولاً شامل موارد زیر است:

\begin{itemize}
    \item ابهام‌سازی جریان کنترل (\lr{Control Flow Obfuscation})
    \item درهم‌سازی داده (\lr{Data Obfuscation})
    \item رمزگذاری پویا (\lr{Dynamic Code Encryption})
    \item رشته‌های رمزگذاری‌شده (\lr{Encrypted Strings})
    \item قطعه‌قطعه کردن کد (\lr{Code Splitting})
    \item بازسازی مرحله‌ای کد (\lr{Staged Reconstruction})
\end{itemize}

چنین ساختاری پیچیدگی زیادی ایجاد می‌کند و حتی ابزارهایی مانند \lr{Ghidra} تنها می‌توانند بخش‌هایی از \lr{CFG} را بازسازی کنند و تحلیل کامل برنامه غیرممکن می‌شود \cite{eagle2020ida,andriesse2018binary}.

\subsection{رفتار آگاه از تحلیل}
\label{sec:analysis-aware}

این تکنیک بر اساس این اصل عمل می‌کند که برنامه بتواند وجود تحلیلگر یا ابزار تحلیل را تشخیص دهد و مسیر اجرای خود را تغییر دهد. این رفتارها معمولاً شامل موارد زیر هستند:

\paragraph{شناسایی \lr{Breakpoint}}  
ابزارهایی مانند \lr{IDA Pro} و \lr{x64dbg} هنگام قرار دادن نقطه توقف تغییراتی در حافظه ایجاد می‌کنند که قابل شناسایی است \cite{eagle2020ida}.

\paragraph{تحلیل زمان‌بندی (\lr{Timing Analysis})}  
اجرای برنامه در \lr{VM} یا \lr{Emulator} باعث تغییر رفتار زمانی می‌شود. یک حلقه ساده با شمارنده می‌تواند اختلاف را آشکار کند.

\paragraph{تشخیص محیط سندباکس}  
سندباکس‌هایی مانند \lr{Cuckoo Sandbox} دارای نشانه‌هایی همچون:
\begin{itemize}
    \item پردازه‌های تکراری،
    \item اندازه ثابت حافظه،
    \item \lr{MAC Address}های غیرواقعی،
    \item فایل‌های سیستم شبیه‌سازی‌شده
\end{itemize}
هستند و برنامه می‌تواند با چند بررسی ساده آنها را شناسایی کند \cite{egele2012survey}.

\paragraph{واکنش به تحلیل}  
در صورت شناسایی تحلیلگر، برنامه ممکن است:
\begin{itemize}
    \item مسیر اجرای واقعی را پنهان کند،
    \item اجرای جعلی نمایش دهد،
    \item بخش‌هایی از کد را بازنویسی کند،
    \item یا اجرای خود را متوقف سازد.
\end{itemize}

\subsection{وابستگی به سخت‌افزار واقعی}
\label{sec:hardware-dependent}

بخش‌های حساس برنامه می‌توانند به ویژگی‌های سخت‌افزاری واقعی وابسته شوند که در \lr{VM} یا \lr{Emulator} قابل شبیه‌سازی دقیق نیستند:

\begin{itemize}
    \item شمارنده‌های سخت‌افزاری (\lr{Performance Monitoring Unit})
    \item رفتار دقیق \lr{Cache L1/L2}
    \item وقفه‌های سیستم‌عامل
    \item زمان‌بندی چرخه \lr{CPU} (\lr{RDTSC})
\end{itemize}

این وابستگی‌ها باعث می‌شوند تحلیل دقیق در محیط شبیه‌سازی‌شده غیرممکن باشد \cite{andriesse2018binary}.

\subsection{جریان کنترل غیرقطعی}
\label{sec:nondeterministic-cfg}

در این روش، جریان کنترل برنامه در اجرای‌های مختلف تغییر می‌کند. این تغییرات ممکن است ناشی از:
\begin{itemize}
    \item داده‌های تصادفی،
    \item زمان دقیق اجرا،
    \item وقفه‌های خارجی،
    \item تخصیص حافظه متفاوت
\end{itemize}

نتیجه:
\begin{itemize}
    \item \lr{CFG} ناپایدار می‌شود،
    \item اجرای نمادین (\lr{Symbolic Execution}) شکست می‌خورد،
    \item مسیر اجرای برنامه قابل بازتولید نیست.
\end{itemize}

\subsection{کد خودتغییر‌دهنده چندمرحله‌ای}
\label{sec:multi-stage-smc}

در نسخه چندمرحله‌ای، هر مرحله فقط بخش کوچکی از کد را بازسازی می‌کند، مرحله بعد فقط پس از اجرای مرحله قبل قابل دستیابی است، هیچ \lr{Dump} کاملی از کد وجود ندارد و خروجی برنامه در هر اجرا متفاوت است \cite{dang2014practical,ugarte2019resilience}.

\subsection{جمع‌بندی}

مقاومت در برابر \lr{Anti-Anti-Disassembly} یعنی ایجاد تکنیک‌هایی که حتی پس از عبور تحلیلگر از موانع اولیه، روند تحلیل را کند، ناقص یا غیرقابل اعتماد می‌سازند. ترکیب روش‌هایی مانند:
\begin{itemize}
    \item ابهام‌سازی لایه‌ای،
    \item رفتار آگاه از تحلیل،
    \item وابستگی سخت‌افزاری،
    \item جریان کنترل غیرقطعی،
    \item بازنویسی چندمرحله‌ای کد
\end{itemize}
سطحی از محافظت ایجاد می‌کند که حتی ابزارهای پیشرفته نیز قادر به تحلیل پایدار آن نیستند.
