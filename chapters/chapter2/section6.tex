\section{استفاده از روش‌های شکست کدهای خود تغییر}

کدهای خودتغییر (Self-Modifying Code یا SMC) یکی از چالش‌برانگیزترین بخش‌ها در تحلیل و تکامل نرم‌افزار محسوب می‌شوند. در این نوع از برنامه‌ها، کد اجرایی در زمان اجرا اقدام به تغییر بخش‌هایی از خود می‌کند؛ تغییری که می‌تواند شامل بازنویسی دستورالعمل‌ها، جابه‌جایی بخش‌های کد، رمزگذاری و رمزگشایی پویا یا تولید ساختارهای جدید اجرایی باشد. دلیل اصلی استفاده از این تکنیک، جلوگیری از تحلیل معکوس، پیچیده‌سازی روند اشکال‌زدایی یا بهبود عملکرد در وضعیت‌های خاص است. به همین دلیل، این روش بیشتر در بدافزارها، سیستم‌های حفاظتی نرم‌افزار، مفسرها، موتورهای مجازی و برخی سیستم‌های بهینه‌سازی دیده می‌شود.  

از آنجا که رفتار کد در هر مرحله می‌تواند تغییر کند، تحلیل آن با روش‌های سنتی بسیار دشوار است. نه‌تنها مسیر اجرای برنامه قابل پیش‌بینی نیست، بلکه حتی ساختار کلی باینری نیز در طول اجرا ثابت نمی‌ماند. بنابراین نیاز به مجموعه‌ای از تکنیک‌ها و ابزارهای تخصصی وجود دارد که بتوانند این نوع رفتار پویا را شناسایی، ردیابی و تحلیل کنند. هدف اصلی روش‌های شکست کدهای خودتغییر، شفاف‌سازی روند تغییرات و ارائه‌ی تصویری ثابت یا حداقل قابل‌درک از ساختار نهایی و مسیرهای اجرایی برنامه است.  


\subsection{تکنیک‌هایی که به شکستن کدهایی که خودشان را تغییر می‌دهند کمک می‌کند}

برای مقابله با کدهای خودتغییر، تحلیل‌گران از مجموعه‌ای از تکنیک‌های دقیق، ترکیبی و گاهی چندمرحله‌ای استفاده می‌کنند. یکی از مهم‌ترین روش‌ها \lr{Controlled Dynamic Execution} است؛ جایی که برنامه در یک شبیه‌ساز یا ابزار چندلایه اجرا شده و هر تغییر در حافظه، رجیسترها یا بخش‌های اجرایی ضبط می‌شود. این روش به تحلیل‌گر اجازه می‌دهد لحظه‌ای که کد دچار تغییر می‌شود را شناسایی کرده و نسخه‌ی قبل و بعد از تغییر را استخراج کند.  

روش رایج دیگر، \lr{Snapshot-Based Analysis} است. در این روش، وضعیت کامل حافظه در بازه‌های زمانی مختلف ذخیره شده و تفاوت آن‌ها مقایسه می‌شود. این مقایسه می‌تواند به‌سرعت نقاطی از حافظه که در حال بازنویسی هستند را مشخص کند. ابزارهایی مانند \lr{QEMU}، \lr{PANDA} یا \lr{Intel PIN} در این حوزه بسیار کاربرد دارند.  

\lr{Dynamic Unpacking} و \lr{Deobfuscation} پویا از دیگر تکنیک‌های مهم محسوب می‌شود. بسیاری از کدهای خودتغییر ابتدا نسخه‌ی رمزگذاری‌شده یا فشرده‌ی خود را اجرا می‌کنند و در زمان اجرا نسخه‌ی واقعی را تولید می‌کنند. تحلیل‌گران با دنبال‌کردن این فرآیند و استخراج نسخه‌ی «بازشده»، تلاش می‌کنند کد را به وضعیت پایدار برگردانند.  

تکنیک مهم دیگر، نظارت بر نواحی حافظه‌ای است که هم قابل‌نوشتن و هم قابل‌اجرا هستند \lr{(Write-Execute Regions)}. در این نواحی احتمال وجود رفتار خودتغییر بالا است. تحلیل‌گران با مانیتورکردن این بخش‌ها یا با فعال‌کردن محافظت‌هایی مانند \lr{W\^X} می‌توانند فعالیت‌های مشکوک را شناسایی کنند.  

در موارد پیشرفته‌تر، ترکیبی از \lr{Static Slicing} و \lr{Dynamic Taint Analysis} استفاده می‌شود تا مشخص شود چه بخش‌هایی از برنامه باعث تغییر بقیه بخش‌ها شده‌اند. این روش به تحلیل‌گر کمک می‌کند منبع تغییرات و مسیرهای داده‌ای که منجر به بازنویسی کد شده‌اند را شناسایی کند.  

در نهایت، نتیجه‌ی این تکنیک‌ها ایجاد یک نسخه‌ی شبه‌پایدار از برنامه است که برای تحلیل، مهندسی معکوس یا ارزیابی امنیتی قابل استفاده است. این فرآیند اگرچه چالش‌برانگیز است، اما یکی از مهم‌ترین بخش‌های تحلیل کدهای سطح پایین و بدافزارهای پیشرفته محسوب می‌شود و نقش مهمی در تکامل نرم‌افزار، امنیت و درک بهتر رفتار سیستم‌های پیچیده ایفا می‌کند.
