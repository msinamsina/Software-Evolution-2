\section{تکنیک‌های رمزگشایی و تحلیل کدهای رمزگذاری‌شده (\lr{Decryption Techniques})}
بخش اعظمی از بدافزارهای مدرن برای جلوگیری از تحلیل ایستا و دیس‌اسمبلی، از «پکرها» (\lr{Packers}) و «کریپترها» (\lr{Crypters}) استفاده می‌کنند. در این حالت، فایل اجرایی روی دیسک ترکیبی از داده‌های رمزگذاری شده و یک قطعه کد کوچک برای بازگردانی (\lr{Stub}) است. هدف از تکنیک‌های رمزگشایی در تحلیل بدافزار، شکستن این پوسته محافظ و دستیابی به کد اصلی (\lr{Payload}) است.\cite{yason2007art} \cite{fishbein2025beginners}

\subsection{فرآیند عمومی آنپک کردن (\lr{Generic Unpacking})}
فرآیند آنپک کردن بر یک اصل ساده استوار است: بدافزار برای اجرا شدن \textit{باید} در نقطه‌ای از زمان، کد خود را رمزگشایی کرده و در حافظه بنویسد. تحلیلگران از این رفتار اجباری برای شکار کد اصلی استفاده می‌کنند.

\subsubsection*{شناسایی نقطه ورود اصلی (\lr{Original Entry Point - OEP})}
هدف نهایی در آنپک کردن، یافتن \textbf{\lr{OEP}} است؛ آدرسی که پس از پایان عملیات رمزگشایی توسط \lr{Stub}، کنترل اجرا به آن منتقل می‌شود و کد اصلی بدافزار آغاز می‌گردد. روش‌های هیوریستیک متعددی برای یافتن \lr{OEP} وجود دارد: \cite{lenoir2015implementing}
\begin{enumerate}
    \item \textbf{رهگیری نوشتن در حافظه (\lr{Memory Write Detection}):} با استفاده از ابزارهای دیباگ (مانند \lr{x64dbg}) یا \lr{DBI}، نقاطی که برنامه در آن‌ها اقدام به نوشتن داده می‌کند (توابعی مانند \texttt{VirtualAlloc} و \texttt{WriteProcessMemory}) نظارت می‌شوند. بخشی از حافظه که پس از نوشتن، دستورات اجرایی در آن قرار می‌گیرند و مجوز اجرا (\lr{Execute Permission}) دریافت می‌کنند، کاندیدای اصلی \lr{OEP} است.
    \item \textbf{تکنیک آنتروپی (\lr{Entropy Heuristics}):} کدهای پک شده به دلیل فشرده‌سازی یا رمزنگاری، آنتروپی (بی‌نظمی) بسیار بالایی دارند. تحلیلگران با پایش تغییرات آنتروپی بلوک‌های حافظه در زمان اجرا، لحظه‌ای را که آنتروپی یک بلوک حافظه به طور ناگهانی کاهش می‌یابد (نشان‌دهنده تبدیل داده‌های رمزگذاری شده به کد اسمبلی معنادار)، به عنوان لحظه آنپک شدن شناسایی می‌کنند.
    \item \textbf{بازسازی رجیسترها (\lr{Stack Balancing}):} بسیاری از پکرها (مانند \lr{UPX}) در ابتدای اجرا وضعیت تمام رجیسترها را در پشته ذخیره می‌کنند (دستور \texttt{PUSHAD}) و دقیقاً قبل از پرش به \lr{OEP}، آن‌ها را بازیابی می‌کنند (\texttt{POPAD}). قرار دادن یک نقطه توقف سخت‌افزاری (\lr{Hardware Breakpoint}) روی آدرس پشته‌ای که رجیسترها در آن ذخیره شده‌اند، می‌تواند تحلیلگر را مستقیماً به لحظه پرش به \lr{OEP} هدایت کند.
\end{enumerate}

\subsection{بازسازی جدول آدرس واردات (\lr{IAT Reconstruction})}
یکی از پیچیده‌ترین مراحل پس از استخراج کد آنپک شده از حافظه، بازسازی \textbf{جدول آدرس واردات (\lr{Import Address Table - IAT})} است. \lr{IAT} جدولی است که آدرس توابع \lr{API} مورد نیاز برنامه (مانند توابع \texttt{Kernel32.dll} یا \texttt{User32.dll}) در آن قرار دارد. پکرها برای سخت‌تر کردن تحلیل، \lr{IAT} اصلی را تخریب کرده و تمام فراخوانی‌های تابع را به روتین‌های داخلی خود هدایت می‌کنند.

اگر فایل دامپ شده از حافظه دارای \lr{IAT} بازسازی شده نباشد، اجرا نخواهد شد. فرآیند بازسازی شامل مراحل زیر است:
\begin{enumerate}
    \item \textbf{کشف الگوی فراخوانی:} تحلیلگر باید کدهای آنپک شده را بررسی کند تا ببیند فراخوانی‌های غیرمستقیم (\lr{Indirect Calls}) به کجا اشاره می‌کنند.
    \item \textbf{استفاده از ابزارهای بازسازی (\lr{Scylla / ImpRec}):} ابزارهایی مانند \lr{Scylla} به پردازه معلق شده متصل می‌شوند، جدول \lr{IAT} موجود در حافظه را اسکن می‌کنند، توابع نامعتبر یا تغییر مسیر داده شده توسط پکر را شناسایی کرده و آن‌ها را با آدرس‌های صحیح \lr{API}های سیستم‌عامل جایگزین می‌کنند.
    \item \textbf{مدیریت بایت‌های دزدیده شده (\lr{Stolen Bytes}):} برخی پکرها تکنیک پیشرفته‌ای به نام "\lr{Stolen Bytes}" را به کار می‌برند؛ آن‌ها چند دستور اول توابع \lr{API} یا کد اصلی را حذف کرده و آن‌ها را در فضای حافظه تخصیص یافته خود اجرا می‌کنند. بازسازی این موارد نیازمند تحلیل دستی دقیق و کپی بازگشتی این دستورات به فایل اصلی است تا فایل قابلیت اجرای مجدد (\lr{Re-runnable}) پیدا کند.
\end{enumerate}

\subsection{رمزگشایی الگوریتم‌های اختصاصی و رشته‌ها}
علاوه بر پکینگ کلی فایل، بدافزارها اغلب رشته‌های حساس (مانند آدرس \lr{C2}، نام فایل‌ها و دستورات) را با الگوریتم‌های اختصاصی رمزگذاری می‌کنند. تحلیلگران برای شکستن این لایه از روش‌های زیر استفاده می‌کنند:

\begin{itemize}
    \item \textbf{شناسایی حلقه‌های رمزگشایی (\lr{Decryption Loops}):} در سطح اسمبلی، روتین‌های رمزگشایی معمولاً با الگوی خاصی ظاهر می‌شوند: یک حلقه تکرار (\lr{Loop}) که روی بافری از داده‌ها عملیات منطقی (مانند \lr{XOR, NOT}) یا شیفت (\lr{ROL/ROR}) انجام می‌دهد. با استفاده از تحلیل گراف جریان کنترل (\lr{CFG}) در دیس‌اسمبلرها، این ساختارها به سرعت قابل شناسایی هستند.
    \item \textbf{تشخیص ثابت‌های رمزنگاری (\lr{Cryptographic Constants}):} بسیاری از الگوریتم‌های استاندارد (مانند \lr{AES, MD5, SHA}) از مقادیر ثابت منحصر به فردی (\lr{S-Boxes} یا مقادیر اولیه بردار) استفاده می‌کنند. ابزارهایی مانند \textbf{\lr{Krypto Analyzer}} در دیس‌اسمبلرها یا اسکریپت‌های \textbf{\lr{FindCrypt}} می‌توانند با جستجوی این ثابت‌ها در کد باینری، نوع الگوریتم رمزنگاری را تشخیص دهند.
    \item \textbf{استخراج کلید با اجرای نمادین (\lr{Symbolic Execution}) و \lr{DBI}:} به جای تلاش برای مهندسی معکوس کامل الگوریتم ریاضی که زمان‌بر است، تحلیلگران از \lr{DBI} استفاده می‌کنند تا آرگومان‌های توابع رمزنگاری را در لحظه فراخوانی شنود کنند. با هوک کردن توابع قبل از ورود به روتین رمزنگاری، می‌توان «کلید» و «متن آشکار» (\lr{Plaintext}) را مستقیماً از حافظه استخراج کرد. این روش به ویژه در برابر بدافزارهای باج‌گیر (\lr{Ransomware}) برای استخراج کلیدهای رمزنگاری فایل‌ها حیاتی است.
\end{itemize}