\section{مقاومت در برابر تحلیل‌های ضد ضد دیس‌اسمبلی}
\label{sec:anti-anti-disassembly}

با پیشرفت گسترده ابزارهای تحلیل معکوس، تکنیک‌های کلاسیک ضد دیس‌اسمبلی دیگر به‌تنهایی نمی‌توانند امنیت کافی فراهم کنند. ابزارهای مدرن همچون \lr{IDA Pro}، \lr{Ghidra}، \lr{Binary Ninja}، \lr{Radare2} و چارچوب‌های تحلیل پویا مانند \lr{DynamoRIO} و \lr{Intel PIN} قادرند بسیاری از تکنیک‌های قدیمی را شناسایی، نرمال‌سازی یا خنثی کنند \cite{eagle2020ida}. همچنین، موتورهای تحلیل نمادین (\lr{Symbolic Execution}) مانند \lr{angr} و \lr{KLEE} توانایی عبور از بسیاری از موانع جریان کنترل را فراهم آورده‌اند.

در چنین شرایطی، نیاز به روش‌هایی برای ایجاد «لایه‌های مقاومت در برابر ابزارهای \lr{Anti-Anti-Disassembly}}» به‌وجود آمده است. این روش‌ها نه‌تنها تحلیل استاتیک را دشوار می‌سازند، بلکه تحلیل پویا، اجرای نمادین و روش‌های خودکار پیشرفته را نیز با شکست مواجه می‌کنند. در ادامه، مجموعه‌ای از تکنیک‌های مدرن برای ایجاد مقاومت پایدار در برابر تحلیلگر انسانی و ابزارهای \lr{AADA} بررسی می‌شود.

\subsection{لایه‌بندی چندمرحله‌ای ابهام‌سازی}
\label{sec:multi-layer-obfuscation}

در روش‌های کلاسیک، ابهام‌سازی معمولاً سطحی و قابل پیش‌بینی بود؛ اما ابزارهای ضد مبهم‌سازی امروزی می‌توانند بسیاری از این موارد را بازگردانی کنند. در مقابل، روش‌های جدید مبتنی بر \textbf{ابهام‌سازی چندمرحله‌ای و وابسته} هستند؛ به‌گونه‌ای که حذف یک لایه باعث فعال شدن لایه‌های دیگر یا ایجاد رفتار اشتباه می‌شود \cite{dang2014practical}.

این لایه‌ها شامل موارد زیر هستند:

\begin{itemize}
    \item ابهام‌سازی جریان کنترل (\lr{Control Flow Obfuscation})
    \item درهم‌سازی داده‌ها (\lr{Data Obfuscation})
    \item رمزگذاری پویا (\lr{Dynamic Code Encryption})
    \item رشته‌های رمزگذاری‌شده
    \item بازسازی مرحله‌ای کد (\lr{Staged Reconstruction})
    \item تکه‌تکه‌سازی کد (\lr{Code Splitting})
\end{itemize}

به دلیل وجود این لایه‌ها، ابزارهایی مانند \lr{Ghidra} یا \lr{Binary Ninja} غالباً تنها قادر به بازیابی بخش‌هایی از نمودار جریان کنترل (\lr{CFG}) هستند، در حالی که تحلیل کامل سیستم غیرممکن می‌شود \cite{andriesse2018binary}.

\subsection{رفتار آگاه از تحلیل}
\label{sec:analysis-aware}

در این تکنیک، برنامه قادر است وجود تحلیلگر یا محیط تحلیل را تشخیص دهد و مسیر اجرای خود را تغییر دهد. این رفتارها معمولاً شامل موارد زیر است:

\paragraph{شناسایی \lr{Breakpoint}}  
ابزارهایی مانند \lr{IDA Pro} و \lr{x64dbg} هنگام قرار دادن نقطه توقف، تغییراتی در حافظه ایجاد می‌کنند. برنامه می‌تواند با مقایسه مقادیر حافظه این تغییرات را شناسایی کند \cite{eagle2020ida}.

\paragraph{تحلیل زمان‌بندی (\lr{Timing Analysis})}  
در محیط‌های مجازی یا شبیه‌ساز، سرعت اجرای دستورها متفاوت است. حلقه‌های شمارنده ساده می‌توانند اختلاف زمان را شناسایی کنند.

\paragraph{تشخیص محیط سندباکس}
سندباکس‌هایی مانند \lr{Cuckoo Sandbox} دارای نشانه‌هایی همچون:
\begin{itemize}
    \item پردازه‌های تکراری،
    \item اندازه ثابت حافظه،
    \item \lr{MAC Address}های غیرواقعی،
    \item فایل‌های سیستمی شبیه‌سازی‌شده
\end{itemize}
هستند. برنامه با چند بررسی ساده این موارد را تشخیص می‌دهد \cite{egele2012survey}.

\paragraph{واکنش به تحلیل}  
در صورت تشخیص تحلیلگر، برنامه ممکن است:
\begin{itemize}
    \item مسیر اجرای واقعی را پنهان کند،
    \item اجرای جعلی نمایش دهد،
    \item کد خود را بازنویسی کند،
    \item یا اجرای خود را متوقف سازد.
\end{itemize}

این روش باعث می‌شود حتی ابزارهای \lr{Anti-Anti-Disassembly} نیز نتوانند نسخه‌ای پایدار و قابل اعتماد از برنامه استخراج کنند.

\subsection{وابستگی به سخت‌افزار واقعی}
\label{sec:hardware-dependent}

برخی ویژگی‌های سخت‌افزار واقعی قابل شبیه‌سازی کامل در \lr{VM} یا \lr{Emulator} نیستند. برنامه با وابسته کردن اجرای بخش‌های حساس خود به این ویژگی‌ها مقاومت زیادی در برابر تحلیل ایجاد می‌کند.

نمونه‌هایی از این موارد:
\begin{itemize}
    \item شمارنده‌های سخت‌افزاری \lr{PMU}
    \item رفتار دقیق \lr{Cache L1/L2}
    \item وقفه‌های سیستم‌عامل
    \item مقادیر واقعی دستور \lr{RDTSC}
\end{itemize}

شبیه‌سازها معمولاً نسخه ساده‌شده این ویژگی‌ها را پیاده‌سازی می‌کنند و همین موضوع امکان تشخیص تحلیل را فراهم می‌کند \cite{andriesse2018binary}.

\subsection{جریان کنترل غیرقطعی}
\label{sec:nondeterministic-cfg}

در این روش، جریان کنترل برنامه در اجرای‌های مختلف تغییر می‌کند. این تغییرات به دلیل:
\begin{itemize}
    \item داده‌های تصادفی،
    \item زمان‌بندی لحظه‌ای،
    \item وقفه‌های خارجی،
    \item تخصیص حافظه متفاوت
\end{itemize}
رخ می‌دهند.

در نتیجه:
\begin{itemize}
    \item نمودار جریان کنترل (\lr{CFG}) ناپایدار می‌شود،
    \item اجرای نمادین (\lr{Symbolic Execution}) شکست می‌خورد،
    \item بازتولید رفتار برنامه غیرممکن می‌شود.
\end{itemize}

ابزارهایی مانند \lr{angr} و \lr{KLEE} تحت این شرایط کارایی خود را از دست می‌دهند \cite{ugarte2019resilience}.

\subsection{کد خودتغییر‌دهنده چندمرحله‌ای}
\label{sec:multi-stage-smc}

در نسخه کلاسیک، کد خودتغییر‌دهنده قابل شناسایی است؛ اما نسخه چندمرحله‌ای آن به‌گونه‌ای طراحی می‌شود که:

\begin{itemize}
    \item هر مرحله فقط بخش کوچکی از کد را بازسازی می‌کند،
    \item مرحله بعد فقط پس از اجرای مرحله قبل قابل دستیابی است،
    \item هیچ \lr{Dump} کاملی از کد در حافظه وجود ندارد،
    \item خروجی برنامه در هر اجرا متفاوت است.
\end{itemize}

در چنین شرایطی، حتی ابزارهای پیشرفته استخراج حافظه نیز قادر به بازسازی نسخه کامل کد نیستند \cite{dang2014practical, ugarte2019resilience}.

\subsection{جمع‌بندی}

مقاومت در برابر تحلیل‌های \lr{Anti-Anti-Disassembly} به‌معنای طراحی مجموعه‌ای از تکنیک‌هاست که حتی پس از عبور تحلیلگر از موانع اولیه، روند تحلیل را کند، ناقص یا غیرممکن سازند. با ترکیب روش‌های لایه‌ای، رفتار آگاه از تحلیل، وابستگی سخت‌افزاری، جریان کنترل غیرقطعی و بازنویسی چندمرحله‌ای کد، سطحی از محافظت ایجاد می‌شود که حتی ابزارهای پیشرفته نیز توانایی تحلیل پایدار آن را نخواهند داشت.
